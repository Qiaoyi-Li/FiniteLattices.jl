var documenterSearchIndex = {"docs":
[{"location":"#FiniteLattices.jl","page":"FiniteLattices.jl","title":"FiniteLattices.jl","text":"","category":"section"},{"location":"#Contents","page":"FiniteLattices.jl","title":"Contents","text":"","category":"section"},{"location":"","page":"FiniteLattices.jl","title":"FiniteLattices.jl","text":"","category":"page"},{"location":"#Lattices","page":"FiniteLattices.jl","title":"Lattices","text":"","category":"section"},{"location":"#FiniteLattices.AbstractLattice","page":"FiniteLattices.jl","title":"FiniteLattices.AbstractLattice","text":" abstract type AbstractLattice\n\nAbstract supertype of all lattices.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteLattices.EmbeddedLattice","page":"FiniteLattices.jl","title":"FiniteLattices.EmbeddedLattice","text":" abstract type EmbeddedLattice{D} <: AbstractLattice\n\nAbstract type of those lattices can be embedded into an Euclidean space ℝ^D. Therefore each point in the lattice has a coordinate, and the distance between two points is induced by the Euclidean metric. \n\nInterfaces should be implemented\n\n size(Latt::EmbeddedLattice) -> ::Int64\n\nReturn the size of the lattice, i.e. the number of sites.\n\n coordinate(Latt::EmbeddedLattice{D}, idx) -> ::NTuple{D, Float64}\n\nReturn the coordinate of a given site.\n\n equiVec(Latt::EmbeddedLattice{D}) -> ::Vector{NTuple{D,Float64}}\n\nReturn the equivalent vectors around the origin point due to the boundary condition. For example, for a square lattice on a torus, there are 9 equivalent vectors (0.0, 0.0), (0.0, ±1.0), (±1.0, 0.0), (±1.0, ±1.0). \n\n\n\n\n\n","category":"type"},{"location":"#FiniteLattices.NonEmbeddedLattice","page":"FiniteLattices.jl","title":"FiniteLattices.NonEmbeddedLattice","text":" abstract type NonEmbeddedLattice <: AbstractLattice\n\nAbstract type of those lattices cannot be embedded into an Euclidean space.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteLattices.SimpleLattice","page":"FiniteLattices.jl","title":"FiniteLattices.SimpleLattice","text":" abstract type SimpleLattice{D, T<:AbstractBoundaryCondition} <: EmbeddedLattice{D}\n\nAbstract type of D-dimensional simple lattices. \n\nFields must be implemented\n\n e::NTuple{D, NTuple{D, Float64}}\n\nPrimitive vectors (e₁, e₂, ...).\n\n sites::Vector{NTuple{D, Int64}}\n\nSites of the finite lattice, each site is represented by the coefficients of primitive vectors. For example, site (a, b) has coordinate a*e₁ + b*e₂.\n\n BC::AbstractBoundaryCondition\n\nBoundary condition, used when computing the distance between two sites.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteLattices.CompositeLattice","page":"FiniteLattices.jl","title":"FiniteLattices.CompositeLattice","text":" struct CompositeLattice{D, N, T} <: EmbeddedLattice{D}\n      subLatts::T\n      shift::NTuple{N, NTuple{D, Float64}}\n      sites::Vector{NTuple{2, Int64}}\n end\n\nWrapper type of composite lattices.\n\nFields\n\n subLatts::NTuple{N, SimpleLattice}\n\nList of the sublattices of the composite lattice.\n\n shift::NTuple{N, NTuple{D, Float64}}\n\nShift of each sublattice, used when computing the coordinates.\n\n sites::Vector{NTuple{2, Int64}}\n\nLazily collect the sites. The first index denotes the sublattice and the second index denotes the site in it.\n\nConstructors\n\n CompositeLattice{D}(subLatts::NTuple{N, SimpleLattice},\n      shift::NTuple{N, NTuple{D, Float64}} = Tuple(fill(Tuple(zeros(D)), N)))\n\nFinally used constructor. Generating a higher dimensional lattice is supported by given a larger D manually.\n\n CompositeLattice(subLatts::NTuple{N, SimpleLattice{D}},\n      shift::NTuple{N, NTuple{D, Float64}} = Tuple(fill(Tuple(zeros(D)), N))) \n CompositeLattice(Latt1, Latt2, ..., shift)\n\nDeduce D from the sublattices or shift. Each sublattice must have the same dimension in this usage.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteLattices.AbstractBoundaryCondition","page":"FiniteLattices.jl","title":"FiniteLattices.AbstractBoundaryCondition","text":" abstract type AbstractBoundaryCondition\n\n\n\n\n\n","category":"type"},{"location":"#FiniteLattices.OpenBoundaryCondition","page":"FiniteLattices.jl","title":"FiniteLattices.OpenBoundaryCondition","text":" struct OpenBoundaryCondition <: AbstractBoundaryCondition\n\n\n\n\n\n","category":"type"},{"location":"#FiniteLattices.PeriodicBoundaryCondition","page":"FiniteLattices.jl","title":"FiniteLattices.PeriodicBoundaryCondition","text":" struct PeriodicBoundaryCondition{D} <: AbstractBoundaryCondition \n      V::NTuple{D,Int64}\n end\n\nPeriodic boundary condition in D dimensions. V denotes the vector of the periodicity. For example, V = (0, W) means the site (a, b) is equivalent to (a, b+W) and thus forms a YC boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteLattices.TwistBoundaryCondition","page":"FiniteLattices.jl","title":"FiniteLattices.TwistBoundaryCondition","text":" struct TwistBoundaryCondition{D} <: AbstractBoundaryCondition \n      V::NTuple{D,Int64}\n      θ::Float64\n end\n\nTwist boundary condition in D dimensions. V denotes the vector of the periodicity. θ ∈ (0, 2π) is the twist angle, means c_{r+V} = e^{-iθ}c_{r}. Note θ = 0 results in a periodic boundary condition and thus is not allowed. \n\n\n\n\n\n","category":"type"},{"location":"#FiniteLattices.CompositeBoundaryCondition","page":"FiniteLattices.jl","title":"FiniteLattices.CompositeBoundaryCondition","text":" struct CompositeBoundaryCondition{N, T} <: AbstractBoundaryCondition\n      BC::T\n end\n\nWrapper of multiple boundary conditions. BC is a tuple of boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteLattices.SquareLattice","page":"FiniteLattices.jl","title":"FiniteLattices.SquareLattice","text":" struct SquareLattice{D,T<:AbstractBoundaryCondition} <: SimpleLattice{D, T}\n      e::NTuple{D,NTuple{D,Float64}}\n      sites::Vector{NTuple{D,Int64}}\n      BC::T\n end\n\nConcrete type of D-dimensional square lattices. \n\n\n\n\n\n","category":"type"},{"location":"#FiniteLattices.OpenSqua","page":"FiniteLattices.jl","title":"FiniteLattices.OpenSqua","text":" OpenSqua(L::Int64, W::Int64) -> ::SquareLattice\n\nConstruct an open L × W square lattice.\n\n\n\n\n\n","category":"function"},{"location":"#FiniteLattices.YCSqua","page":"FiniteLattices.jl","title":"FiniteLattices.YCSqua","text":" YCSqua(L::Int64, W::Int64, θ::Real = 0.0) -> ::SquareLattice\n\nConstruct a YC L × W square lattice, where θ is the twist angle, e.g. θ = 0 means PBC and θ = π means APBC.\n\n\n\n\n\n","category":"function"},{"location":"#FiniteLattices.TriangularLattice","page":"FiniteLattices.jl","title":"FiniteLattices.TriangularLattice","text":" struct TriangularLattice{D, T<:AbstractBoundaryCondition} <: SimpleLattice{D, T}\n      e::NTuple{D,NTuple{D,Float64}}\n      sites::Vector{NTuple{D,Int64}}\n      BC::T\n end\n\nConcrete type of triangular lattices. Note we only assume each layer is a triangular lattice if D > 2.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteLattices.YCTria","page":"FiniteLattices.jl","title":"FiniteLattices.YCTria","text":" YCTria(L::Int64, W::Int64, θ::Real = 0.0;\n      reflect::Bool = false,\n      scale::Real = 1.0) -> ::TriangularLattice\n\nConstruct a YC L × W triangular lattice, where θ is the twist angle, e.g. θ = 0 means PBC and θ = π means APBC.\n\nkwargs\n\n reflect::Bool = false\n\nIf reflect = true, reflect the lattice along the x axis from the default convention.\n\n scale::Real = 1.0\n\nThe scale factor of the lattice. scale = 1.0 means the length of the primitive vectors equals to 1.0.\n\n\n\n\n\n","category":"function"},{"location":"#FiniteLattices.XCTria","page":"FiniteLattices.jl","title":"FiniteLattices.XCTria","text":" XCTria(L::Int64, W::Int64,  θ::Real = 0.0;\n      reflect::Bool = false,\n      scale::Real = 1.0) -> ::TriangularLattice\n\nConstruct a XC L × W triangular lattice, where θ is the twist angle, e.g. θ = 0 means PBC and θ = π means APBC. \n\nkwargs\n\n reflect::Bool = false\n\nIf reflect = true, reflect the lattice along the y axis from the default convention.\n\n scale::Real = 1.0\n\nThe scale factor of the lattice. scale = 1.0 means the length of the primitive vectors equals to 1.0.\n\n\n\n\n\n","category":"function"},{"location":"#FiniteLattices.OHTria","page":"FiniteLattices.jl","title":"FiniteLattices.OHTria","text":" OHTria(L::Int64) -> ::TriangularLattice\n\nConstruct a triangular lattice in an open hexagon with L sites in a side.  \n\n\n\n\n\n","category":"function"},{"location":"#FiniteLattices.YCHoneycomb","page":"FiniteLattices.jl","title":"FiniteLattices.YCHoneycomb","text":" YCHoneycomb(L::Int64, W::Int64, θ::Real = 0.0; scale::Real = 1.0) -> ::CompositeLattice\n\nConstruct a YC L × W honeycomb lattice, where θ is the twist angle. Note YC honeycomb lattice is a XC triangular lattice with 2 sites per unit cell.\n\nkwargs\n\n scale::Real = 1.0\n\nThe scale factor of the lattice, which equals to the distance between the nearest neighbor unit cells. Thus, use scale = sqrt(3) to make the length of the NN bond equals to 1.0.\n\n\n\n\n\n","category":"function"},{"location":"#FiniteLattices.XCHoneycomb","page":"FiniteLattices.jl","title":"FiniteLattices.XCHoneycomb","text":" XCHoneycomb(L::Int64, W::Int64, θ::Real = 0.0; kwargs...) -> ::CompositeLattice\n\nConstruct a XC L × W honeycomb lattice, where θ is the twist angle. Note XC honeycomb lattice is a YC triangular lattice with 2 sites per unit cell. \n\nkwargs\n\n scale::Real = 1.0\n\nThe scale factor of the lattice, which equals to the distance between the nearest neighbor unit cells. Thus, use scale = sqrt(3) to make the length of the NN bond equals to 1.0.\n\n\n\n\n\n","category":"function"},{"location":"#Methods","page":"FiniteLattices.jl","title":"Methods","text":"","category":"section"},{"location":"#FiniteLattices.coordinate","page":"FiniteLattices.jl","title":"FiniteLattices.coordinate","text":" coordinate(Latt::EmbeddedLattice{D}, idx) -> ::NTuple{D, Float64}\n\nReturn the coordinate of a given site.\n\n\n\n\n\n","category":"function"},{"location":"#FiniteLattices.distance","page":"FiniteLattices.jl","title":"FiniteLattices.distance","text":" distance(Latt::EmbeddedLattice, idx1::Ind64, idx2::Int64) -> ::Float64\n\nReturn the distance between two sites.\n\n\n\n\n\n","category":"function"},{"location":"#FiniteLattices.Zigzag!","page":"FiniteLattices.jl","title":"FiniteLattices.Zigzag!","text":" Zigzag!(Latt::EmbeddedLattice) -> Latt\n\nSort sites according to zigzag path, i.e. lexicographic order where last dimension first. \n\n\n\n\n\n","category":"function"},{"location":"#FiniteLattices.Snake!","page":"FiniteLattices.jl","title":"FiniteLattices.Snake!","text":" Snake!(Latt::SimpleLattice{2}) -> Latt\n\nSort sites according to snake path, i.e. lexicographic order up to an even-odd modulation. \n\n\n\n\n\n","category":"function"},{"location":"#FiniteLattices.neighbor","page":"FiniteLattices.jl","title":"FiniteLattices.neighbor","text":" neighbor(Latt::EmbeddedLattice, i::Int64; kwargs...) -> ::Vector{Int64}\n\nReturn all the neighbor sites of a given site.\n\n neighbor(Latt::EmbeddedLattice; kwargs...) -> ::Vector{NTuple{2, Int64}}\n\nReturn all neighbor pairs of a given lattice.\n\nKwargs\n\n d::Union{Missing, Real} = missing\n\nThe distance between the two sites of the neighbor pair.\n\n level::Int64 = 1\n\nThe neighbor level, e.g. level = 1 means the nearest neighbor, level = 2 means the next nearest neighbor, etc. Note it is defined by the total lattice, instead of the given site i. Note the priority is d > level.\n\n ordered::Bool = false\n\nView (i,j) as an ordered pair if true, i.e. (i,j) ≠ (j,i).\n\n\n\n\n\n","category":"function"},{"location":"#FiniteLattices.equiVec","page":"FiniteLattices.jl","title":"FiniteLattices.equiVec","text":" equiVec(Latt::EmbeddedLattice{D}) -> ::Vector{NTuple{D,Float64}}\n\nReturn the equivalent vectors around the origin point due to the boundary condition. For example, for a square lattice on a torus, there are 9 equivalent vectors (0.0, 0.0), (0.0, ±1.0), (±1.0, 0.0), (±1.0, ±1.0). \n\n\n\n\n\n","category":"function"},{"location":"#FiniteLattices.relaVec","page":"FiniteLattices.jl","title":"FiniteLattices.relaVec","text":" relaVec(Latt::EmbeddedLattice, idx1::Int64, idx2::Int64) -> ::NTuple{D, Float64}\n\nReturn the nearest relative vector between the two sites. Note PBC is considered.\n\n\n\n\n\n","category":"function"},{"location":"#FiniteLattices.intrapair","page":"FiniteLattices.jl","title":"FiniteLattices.intrapair","text":" intrapair(Latt::CompositeLattice, idx::Int64; kwargs...) -> ::Vector{NTuple{2, Int64}}\n\nSimilar to neighbor, but only return the intra-sublattice pairs of the idx sublattice.\n\n intrapair(Latt::CompositeLattice,\n      lsidx::AbstractVector{Int64} = 1:N;\n      kwargs...) -> ::Vector{NTuple{2, Int64}}\n\nCollect all the intra-sublattice pairs of the given sublattices.\n\nKwargs\n\n d::Union{Missing, Real} = missing\n\nThe distance between the two sites of the neighbor pair.\n\n level::Int64 = 1\n\nThe neighbor level, note the inter-sublattice pairs will be ignored when calculating the distance with given level.\n\n ordered::Bool = false\n\nView (i,j) as an ordered pair if true, i.e. (i,j) ≠ (j,i).\n\n\n\n\n\n","category":"function"},{"location":"#FiniteLattices.interpair","page":"FiniteLattices.jl","title":"FiniteLattices.interpair","text":" interpair(Latt::CompositeLattice; kwargs...) -> ::Vector{NTuple{2, Int64}}\n\nCollect all the inter-sublattice pairs.\n\n interpair(Latt::CompositeLattice, idx1::Int64, idx2::Int64;\n      kwargs...) -> ::Vector{NTuple{2, Int64}}\n\nSimilar to neighbor, but only return the inter-sublattice pairs (i, j) s.t. i in idx1 and j in idx2 sublattices. Note the kwarg ordered will not affect the result for this usage.\n\nKwargs\n\n d::Union{Missing, Real} = missing\n\nThe distance between the two sites of the neighbor pair.\n\n level::Int64 = 1\n\nThe neighbor level, note the intra-sublattice pairs will be ignored when calculating the distance with given level.\n\n ordered::Bool = false\n\nView (i,j) as an ordered pair if true, i.e. (i,j) ≠ (j,i).\n\n\n\n\n\n","category":"function"},{"location":"#FT","page":"FiniteLattices.jl","title":"FT","text":"","category":"section"},{"location":"#FiniteLattices.FTCoefs","page":"FiniteLattices.jl","title":"FiniteLattices.FTCoefs","text":" FTCoefs(Latt::EmbeddedLattice{D}, k::NTuple{D,Float64}; kwargs...) -> ::Vector{ComplexF64}\n FTCoefs(Latt::EmbeddedLattice{D}, lsk::AbstractVector{NTuple{D,Float64}}; kwargs...) -> ::Matrix{ComplexF64}\n\nReturn the Fourier coefficients corresponding to the given wave vector k, represented by a length N vector where N is the number of sites in the lattice. Note the FT convention is FS(k) = 1/sqrt(N) ∑_r exp(-ik⋅r) S(r).\n\nNote our convention guarantees the FT is orthogonal thus the returned vector is normalized. However, the returned matrix corresponding to multiple k may not be orthogonal since we do not limit the input k list.\n\nkwargs\n\n dims::Int64/Tuple{Vararg{Int64}} = Tuple(1:D)\n\nThe dimensions to perform the partial Fourier transform. For example, dims = (1,) means k = (kₓ, y) will give the coefficients (x, y') -> C e^{-ikₓx}δ(y - y'), where C is a normalization constant. Note it will return NaN if any site in the lattice does not have the same y-coordinate.\n\n\n\n\n\n","category":"function"},{"location":"#FiniteLattices.FT","page":"FiniteLattices.jl","title":"FiniteLattices.FT","text":" FT(Sr::AbstractMatrix,\n      Latt::EmbeddedLattice{D},\n      lsk::AbstractVector = _default_lsk(Latt);\n      dims::Union{Int64, Tuple{Vararg{Int64}}} = Tuple(1:D)\n      ) -> FS::Matrix\n\nFinally used method, apply the Fourier transform Sr(r, n) -> FS(k, n) where n is the column index of the given matrix Sr. \n\nThe FT convention please see FTCoefs.\n\n FT(Sr::AbstractVector,\n      Latt::EmbeddedLattice,\n      lsk::AbstractVector = _default_lsk(Latt);\n      kwargs...\n      ) -> ::Vector\n FT(Sr::AbstractMatrix,\n      Latt::EmbeddedLattice{D},\n      k::NTuple{D,Float64};\n      kwargs...\n      ) -> ::Vector\n\nReturn a vector for single n or k.\n\n FT(Sr::AbstractVector,\n      Latt::EmbeddedLattice{D},\n      k::NTuple{D,Float64};\n      kwargs...\n      ) -> ::ComplexF64\n\nReturn the coefficients when both n and k are single.\n\n FT(Latt::EmbeddedLattice, k; kwargs...) -> f: Sr -> FS\n\nReturn the function instead of applying the FT immediately.\n\n\n\n\n\n","category":"function"},{"location":"#FiniteLattices.FT2","page":"FiniteLattices.jl","title":"FiniteLattices.FT2","text":" FT2(SS::AbstractMatrix,\n      Latt::EmbeddedLattice,\n      k::Tuple;\n      symmetric::Bool=true,\n      dims::Union{Int64, Tuple{Vararg{Int64}}} = Tuple(1:D)\n      ) -> ::ComplexF64/Float64\n\nApply twice Fourier transform with the same k to the input matrix SS. A common use case is to calculate the structure factor from the all to all correlation function. \n\nIf symmetric = true, we assume the input matrix is hermitian and thus the result should be real up to a numerical error. In this case, we will automatically complete the matrix if it is a upper/lower triangular matrix.\n\ndims gives the dimensions to perform the partial Fourier transform, details see function FTCoefs.\n\n FF2(SS::AbstractMatrix,\n      Latt::EmbeddedLattice,\n      lsk::AbstractVector = _default_lsk(Latt);\n      kwargs...) -> ::Vector{ComplexF64/Float64}\n\nReturn a vector by simply broadcasting lsk.\n\n FT2(Latt::EmbeddedLattice, k) -> f: SS -> Sk\n\nReturn the function instead of applying the FT immediately.\n\n\n\n\n\n","category":"function"}]
}
